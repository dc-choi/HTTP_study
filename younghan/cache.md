### 캐시란?
변경될 일이 없는 데이터를 캐시 저장소에 저장하여 서버에 요청을 보내지 않도록 하는 것

### 캐시가 없을 때
데이터가 변경되지 않아도 계속 네트워크를 통해서 데이터를 다운로드 받아야 한다.

인터넷 네트워크는 매우 느리고 비싸다.

브라우저 로딩 속도가 느리다.

느린 사용자 경험

### cache-control이라는 헤더를 응답에 포함해주면 캐시의 유효기간을 설정할 수 있다.
max-age=60(초단위)

요청시 캐시의 유효기간동안은 캐시에서 데이터를 찾게 된다.

### 캐시 적용을 하게되면...
캐시 가능 시간동안 네트워크를 사용하지 않아도 된다.

비싼 네트워크 사용량을 줄일 수 있다.

브라우저 로딩 속도가 매우 빠르다.

빠른 사용자 경험

### 만약 캐시 시간이 초과된다면?
다시 요청을 하게 되고 응답 결과를 다시 캐시에 저장함.

하지만 유효시간이 만료되었음에도 데이터는 바뀌지 않았다면 이것은 낭비.

### 검증헤더를 통해서 실제로 데이터가 바뀌었는지 확인할 수 있다.
Last-Modified 헤더에 마지막으로 데이터를 수정된 시간을 추가한다면 이것을 사용할 수 있음.

Last-Modified 헤더가 브라우저상에 존재한다면 캐시 시간 만료된 경우 if-modified-since 헤더에 수정된 시간을 추가해서 요청을 보낸다.

if-modified-since 헤더를 통해 서버에서 데이터 변경이 되었는지 검증이 가능함.

만약 수정이 되지 않았다면 304 Not Modified를 응답코드로 내려준다. (응답부분의 Body도 없음)

### 정리
캐시 유효 시간이 초과해도, 서버의 데이터가 갱신되지 않으면 304 Not Modified + 헤더 메타 정보만 응답

클라이언트는 서버가 보낸 응답 헤더 정보로 캐시의 메타 정보를 갱신

클라이언트는 캐시에 저장되어 있는 데이터 재활용

결과적으로 네트워크 다운로드가 발생하지만 용량이 적은 헤더 정보만 다운로드

매우 실용적인 해결책

### 검증 헤더
캐시 데이터와 서버 데이터가 같은지 검증하는 데이터

Last-Modified, ETag

### 조건부 요청 헤더
검증 헤더로 조건에 따른 분기

if-modified-since: Last-Modified 사용

if-none-match: ETag 사용

조건이 만족하면 200 OK

조건이 만족하지 않으면 304 Not Modified

### Last-Modified, if-modified-since 단점
1초 미만 단위로 캐시 조정이 불가능

날짜 기반의 로직 사용하여 데이터를 수정해서 날짜가 다르지만, 같은 데이터를 수정해서 데이터 결과가 똑같은 경우

서버에서 별도의 캐시 로직을 관리하고 싶은경우

EX) 스페이스나 주석처럼 크게 영향이 없는 변경에서 캐시를 유지하고 싶은 경우

### ETag, if-none-match
Entity Tag

캐시용 데이터에 임의의 고유한 버전 이름을 달아둠

EX) ETag: "v1.0", ETag: "q1w2e3r4"

데이터가 변경되면 이 이름을 바꾸어서 변경함(Hash를 다시 생성)

진짜 단순하게 ETag만 보내서 같으면 유지, 다르면 다시 받기!

### 정리
진짜 단순하게 ETag만 서버에 보내서 같으면 유지, 다르면 다시 받기!

캐시 제어 로직을 서버에서 완전히 관리

클라이언트는 단순히 이 값을 서버에 제공(클라이언트는 캐시 메커니즘을 모름)

EX)

서버는 배타 오픈 기간인 3일 동안 파일이 변경되어도 ETag를 동일하게 유지

어플리케이션 배포 주기에 맞추어 ETag 모두 갱신

### Cache-Control
캐시 제어(지시어)

사실 이거만 사용해도 상관이 없다고 하심

Cache-Control: max-age

캐시 유효 시간, 초 단위

Cache-Control: no-cache

데이터는 캐시해도 되지만, 항상 origin 서버에 검증하고 사용

Cache-Control: no-store

데이터에 민감한 정보가 있으므로 저장하면 안됨(보통 디스크에 저장된다고 함. 메모리에서 사용만 하고 최대한 빨리 삭제)

### 프록시 캐시
origin 서버가 위치상으로 멀다면 중간에 프록시 캐시 서버를 만듬그래서 위치상 가까운 프록시 캐시 서버에서 응답을 받을 수 있도록 함.

프록시 서버에 있는 캐시를 public, 내 브라우저에 있는 캐시를 private라고 함.

Cache-Control: public

응답이 public 캐시에 저장되어도 됨

Cache-Control: private

응답이 해당 사용자만을 위한 것임, private 캐시에 저장해야 함(기본 값)

Cache-Control: s-maxage

프록시 캐시에만 적용되는 max-age

Age: 60 (HTTP 헤더)

origin 서버에서 응답 후 프록시 캐시 내에 머문 시간

### 캐시 무효화
Cache-Control: no-cache, no-store, must-revalidate (전부 다 넣어야 함)

must-revalidate

캐시 만료 후 최초 조회시 origin 서버에 검증해야 함

origin 서버 접근 실패시 반드시 오류가 발생해야 함 - 504(GateWay Timeout)

must-revalidate는 캐시 유효 시간이라면 캐시를 사용함

### no-cache, must-revalidate의 차이점
no-cache는 origin 서버에 접근할 수 없는 경우 캐시 서버 설정에 따라 캐시 데이터를 반환해줌

must-revalidate는 origin 서버에 접근할 수 없는 경우 항상 오류가 발생해야 함

### 다음으로...
1. HTTP 스펙
	RFC 7230~7235를 확인하기 2616은 옛날...
2. HTTP 완벽 가이드
	RFC 2616 기준임.